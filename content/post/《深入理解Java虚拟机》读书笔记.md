+++
draft = false
image = "https://i.loli.net/2019/03/07/5c8128cbe1e4f.jpg"
showonlyimage = true
date = "2019-3-07T20:23:59+05:30"
title = "《深入理解Java虚拟机》读书笔记"
writer = "子适"
categories = [ "code" ]
weight = 1
+++

《深入理解Java虚拟机》读书笔记

第二章 Java内存区域与内存溢出异常
<!--more-->

# 《深入理解Java虚拟机》读书笔记

## 第二章 Java内存区域与内存溢出异常

### 2.1 虚拟机内存总览

![虚拟机内存](https://i.loli.net/2019/03/07/5c8128cbe1e4f.jpg)

- 其中，方法区 和 堆 是所有进程共享的数据区域。 其余是每个进程独占的区域。

### 2.2 各个区域介绍

#### 2.2.1 程序计数器 Program Counter Register

- 线程私有，保证线程轮流切换后能恢复到正确的执行位置。

- 当前线程所执行的字节码的行号指示器。

- 字节码解释器通过改变计数器的值来选取下一条需要执行的字节码指令。

#### 2.2.2 Java 虚拟机栈 Java Virtual Machine Stacks

- 线程私有

- 描述的是 Java 方法执行的内存模型，每个方法在执行的同时会创建一个栈帧 Stack Frame，用于储存局部变量表、操作数栈等信息。

- 每一个方法从调用到执行完毕，对应一个栈帧在虚拟机栈从入栈到出栈。

- 虚拟机栈中存放有局部变量表。其中存放了编译期间可知的各种基本数据类型、对象引用（reference 类型）。

- 可能抛出的异常—— StackOverflowError 和 OutOfMemoryError

#### 2.2.3 Java 堆 Java Heap

- 所有线程共享的区域，也是虚拟机所管理的内存中最大的一块。
- 唯一目的：存放所有对象实例。
- 垃圾收集器管理的主要区域。
- 不必物理连续的空间，逻辑连续即可。
- 可能抛出异常——OutOfMemoryError

#### 2.2.3 方法区 Method Area

- 线程共享。存储已被虚拟机加载的类信息、常量、静态变量等信息
- 允许不进行垃圾收集
- 可能抛出异常——OutOfMemoryError

### 2.3 对象在虚拟机中的创建、使用

#### 2.3.1 对象的创建

![](https://i.loli.net/2019/03/07/5c8128d1bb135.png)

- 分配内存两种方法
  - Java 堆内存连续——指针碰撞。移动指针，将符合对象大小的内存分配给对象
  - Java 堆内存不连续——空闲类标。维持一个列表，记录哪些内存可用

#### 2.3.2 对象的内存布局

- 对象在内存中的存储分为三部分：
  - 对象头 Header。包括两部分内容：
    - 对象自身运行时数据
    - 类型指针，指向它的类元数据的指针。据此，虚拟机判断对象属于哪个类
  - 实例数据 Instance Data——代码中定义的各种类型的字段内容
  - 对齐填充 Padding——为了对齐而填充的占位符

#### 2.3.3 对象的访问

java 程序需要栈上的 reference 数据来操作堆上的具体对象。

两种访问方式：

- 句柄访问——Java 堆中划出一块区域作为句柄池，reference 存储句柄地址。句柄存储对象实例和类的地址信息。移动对象时只修改句柄中实例数据指针，不必修改reference。

​	![类的生命周期](https://i.loli.net/2019/03/07/5c8128d1921b3.png)


- 直接访问——reference 存储对象地址。速度快。

![](https://i.loli.net/2019/03/07/5c8128d148c11.png)

## 第三章 垃圾收集器与内存分配策略

### 3.1 垃圾收集(Garbage Collection, GC)概述

- 不需要垃圾收集的区域——程序计数器、虚拟机栈、本地方法栈。因为它们随进程创建毁灭。
- 垃圾收集主要区域——堆 和 方法区。主要是堆。

### 3.2 判断对象已死

#### 3.2.1 可达性分析算法 Reachability Analysis

- 通过一系列称为"GC Roots" 的对象作为起始点，向下搜索，所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链想通时（即 GC Roots 和对象之间不可达）。证明该对象不可用。

- Java 中的引用：
  - 强引用——类似 `Object obj = new Object()` ，只要强引用存在，不会被回收
  - 软引用——有用但非必须。内存要溢出时会回收
  - 弱引用——非必需。下次垃圾收集时会被回收
  - 虚引用——最弱的关系，不影响垃圾收集

#### 3.2.2 确定对象死亡过程

- 宣告一个对象已死，经过两次标记过程：
  - 一个对象被判断不可达，经历一次标记
  - 第一次标记后，依据是否有必要执行 finalize() 方法筛选对象。如果对象没有覆盖 finalize() 方法或者该方法已经被虚拟机调用过，则认为没有必要执行。直接回收。
  - 有必要执行 finalize() 方法的对象，被放置于 F-Queue 队列，并在稍后由一个虚拟机创建的、低优先级的 Finalize 线程执行 finalize() 方法。
  - Finalize() 方法是对象最后的自救可能，只要重新引用关系，就会被移除回收队列。
  - 尽量避免使用 `finalize()` 方法。

### 3.3 垃圾收集算法

- 标记-清除算法 ——标记和清除效率都不高；清除之后产生大量不连续的空间，为后来分配内存不便。
- 复制算法——将内存分为两块，一块满了时，将存活对象复制到另一块上，并将这块内存清空。效率高，代价是牺牲一半内存。
  - 现代虚拟机不会分成等大的两份内存。而是将内存分为一块较大的(80%)的Eden空间，和两块较小的Survivor空间(各10%)。每次使用Eden和一块Survivor，满了后将存活对象移到另一块Survivor 上。相当于只浪费了 10 % 的空间。
- 标记-整理算法
- 分代收集算法——将 Java 堆分为新生代和老年代。新生代中随时有大量对象产生和死亡，用复制算法；老年代中存活率高，用标志-清理或者标志-整理算法。

### 3.4 垃圾收集器

- Serial 收集器——最基本的收集器。
  - 单线程。在其执行垃圾收集时，必须暂停所有其他进程。"Stop The World"
- ParNew 收集器——Serial 收集器的多线程版本
  - 多CPU下表现优于Serial
  - 除了Serial，唯一能与CMS配合使用
- Parallel Scavenge 收集器——多线程、复制算法，吞吐量优先收集器
  - 目标：控制CPU吞吐量（运行用户代码时间/总运行时间）
- CMS 收集器——Concurrent Mark Sweep。并发、标记-清除算法，用于老年代收集
  - 目标：获取最短回收停顿时间
- G1 收集器 —— Garbage First。并行并发、分代收集、空间整合、可预测的停顿
  - 有计划的避免在堆全区域收集。跟踪各个Region 中的垃圾堆积的价值，每次根据允许的时间，优先回收价值大的Region。即将垃圾收集区域“化整为零”。



## 第六章 类文件结构

### 6.2 无关性的基石

- 代码编译的结构从机器码转变为字节码（ByteCode），编程语言发展的一大步。
- Java 虚拟机不和任何语言绑定，只与 Class 文件 这种特定的二进制文件格式关联。

### 6.3 Class 类文件的结构

> Class 文件是一组以 8 位字节为基础的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件中，中间没有任何分隔符。

- 实例

```java
public class TestClass{
    private int m;
    public int inc(){
        return m + 1;
    }
}
```

编译产生 TestClass.class

```bash
~/Desktop/Code > javap -verbose TestClass
Classfile /Users/cshi/Desktop/Code/TestClass.class
  Last modified 2019年2月25日; size 275 bytes
  MD5 checksum 17d76d726d583c5c225172cc7af62a0f
  Compiled from "TestClass.java"
public class TestClass
  minor version: 0
  major version: 55
  flags: (0x0021) ACC_PUBLIC, ACC_SUPER
  this_class: #3                          // TestClass
  super_class: #4                         // java/lang/Object
  interfaces: 0, fields: 1, methods: 2, attributes: 1
Constant pool:
   #1 = Methodref          #4.#15         // java/lang/Object."<init>":()V
   #2 = Fieldref           #3.#16         // TestClass.m:I
   #3 = Class              #17            // TestClass
   #4 = Class              #18            // java/lang/Object
   #5 = Utf8               m
   #6 = Utf8               I
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               inc
  #12 = Utf8               ()I
  #13 = Utf8               SourceFile
  #14 = Utf8               TestClass.java
  #15 = NameAndType        #7:#8          // "<init>":()V
  #16 = NameAndType        #5:#6          // m:I
  #17 = Utf8               TestClass
  #18 = Utf8               java/lang/Object
{
  public TestClass();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 1: 0

  public int inc();
    descriptor: ()I
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: getfield      #2                  // Field m:I
         4: iconst_1
         5: iadd
         6: ireturn
      LineNumberTable:
        line 6: 0
}
SourceFile: "TestClass.java"
```

- Class 文件中的两种数据类型：
  - 无符号数——基本类型
  - 表——又多个无符号数或者表组成
- Class 文件格式总表
  - 每个 Class 文件，无论是顺序还是数量，都严格按照这个表格，不允许改变

![class 文件格式](https://i.loli.net/2019/03/07/5c812ac973d8c.png)

- magic ——魔数，判断该文件是否为虚拟机所接受的文件。Class 文件魔数为—— **"0xCAFEBABE"** 
- Minor-version  major-version 主副版本号
- Constant _pool_count、constant_pool ——常量池计数和常量池
  - Class 文件中的资源仓库，最大的数据项目之一。
  - 常量池中两种常量：字面量 Literal 和符号引用 Symbolic Reference
  - 常量池中每一个常量都是一个表。一共有14种不同的表。

- Fields_info 字段表 ，描述接口或者类中生命的变量。包括类级变量和实例变量。不包括方法内部声明的局部变量。
- Attribute_info 属性表——Class 文件、字段表、方法表都可以携带自己的属性表集合。
  - 最重要的属性 —— Code。一个方法不允许超过 65535 条字节码指令
  - 异常处理表现为表结构储存在Code属性中

### 6.4 字节码指令

- Class 文件放弃了编译后代码的操作数长度对齐，损失一定性能，但保证了代码短小精干。
- 不考虑异常处理，虚拟机执行模型如下：

```java
do{
    自动计算 PC 寄存器的值加1;
    根据 PC 寄存器的指示位置，从字节码流中取出操作码;
    if(字节码存在操作数)	从字节码流中取出操作数;
    执行操作码定义操作;
}while( 字节码流长度 > 0);
```

## 第七章 虚拟机类加载机制

- 类加载机制——Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接执行的 Java 类型，
- 动态拓展特性——Java 语言里，类型的加载、连接和初始化都是在程序运行期间完成的。

### 7.2 类加载的时机


![](https://i.loli.net/2019/03/07/5c8128d07cb35.png)


- 其中，解析阶段顺序不固定，可能在初始化后开始
- 各个生命周期按顺序“开始”，而不是进行或结束。通常是相互交叉混合进行的。
- 类加载的时机：有且仅有 5 种情况需要立即初始化类（**类的主动引用**）：
  - `new`、`getstatic`、`putstatic`（调用或设置一个类的静态字段，被 final 修饰的不算）、`invokestatic`（调用一个类的静态方法） 四条指令，触发初始化。
  - 对类进行反射调用时
  - 初始化一个类时，发现其父类还未初始化
  - 虚拟机启动时，初始化主类（含 main 方法的那个）
  - JDK 1.7 动态语言支持， `java.lang.invoke.MethodHandle` 实例，解析结果对应的类
- 接口的加载时机：初始化一个接口时，不会初始化其父接口。其余相同。
- 被动引用的示例，不会导致类的初始化[示例](/Users/cshi/Desktop/Code/JavaPratice/深入理解JVM/虚拟机类加载机制)
  - 子类引用父类的静态字段，子类不会初始化
  - 通过数组引用类，不会导致类的初始化。数组本身不通过加载器创建，是由虚拟机直接创建的。会触发一个 `[Lorg.fenixsoft.classloading.SuperClass` 的类的初始化，继承于 Object，作为容器。
  - 引用类中被 final 修饰的常量。不会导致类的初始化。常量放在常量池中。

### 7.3 类加载过程

#### 加载

- 通过一个类的全限定名来获取定义此类的二进制字节流
- 将这个字节流代表的静态存储结构转化为方法区的运行时的数据结构
- 在内存中生成代表这个类的 `java.lang.class` 对象，最为方法区这个类的各种数据的访问入口

#### 验证

- 确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求
- 分为四类：
  - 文件格式验证
  - 元数据验证——对类元数据进行语义分析，例如有无父类，是否实现接口要求方法等
  - 字节码验证——通过对数据流和控制流分析，确定程序符合逻辑。针对类的方法体。
  - 符号引用验证——发生在解析阶段，将符号引用转换为直接引用时，保证能被正确解析。

#### 准备

- 正式为**类变量**(不是实例变量)分配内存（在方法区中）并设置类变量初始值（系统初始值零值）

#### 解析

将常量池内的符号引用替换为直接引用的过程。

- 类或接口的解析
  - 非数组：利用类的全限定名查找要解析的类并返回
  - 数组：先查找解析的类，然后由虚拟机生成一个代表此数组维度和元素的数组对象
- 字段解析
  - 通过字段表索引到字段所属的类或接口
  - 在类或接口及其父类中查找该字段并返回
- 类方法解析
- 接口方法解析

#### 初始化

初始化阶段，开始正式执行类中定义的 Java 程序代码（字节码）。

- 初始化阶段是执行类构造器 `<clinit>()` 方法的过程
- `<clinit>()` 方法：——相当于实例化对象时的 `<init>()` 方法
  - 编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}）中的语句合并产生。
  - 保证父类的`<clinit>()` 方法先于子类的发生，即父类的静态语句块优于子类的。

### 7.4 类加载器

> 实现“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作的代码块——类加载器

- 同一个类，被不同的类加载器加载，得到的结果不相同。

#### 双亲委派模型 Parents Delegation Model

三种类型的加载器：

- 启动类加载器——负责`<JAVA_HOME>\lib`目录中的类库加载
- 扩展类加载器——负载加载`<JAVA_HOME>\lib\ext`目录中的类库
- 应用程序类加载器——加载用户类路径 ClassPath 上所指定的类库

![双亲委派模型](https://i.loli.net/2019/03/07/5c8128d215e06.png)

- 工作过程：一个类加载器收到加载请求，会先委派到父类加载器加载，当父类加载器反馈自己无法加载该类时，自己才尝试加载。
- 目的：使得 JAVA 类随着类加载器一起具有了一种带有优先级的层次关系。例如：Object 类永远只能被启动类加载器加载，从而避免加载出多种不同的 Object 类。

## 第八章 虚拟机字节码执行引擎

> 从外观（Facade）看，所有执行引擎都是一样的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

### 8.2 运行时的帧栈结构

- 帧栈( Stack Frame) 用于支持虚拟机进行方法调用和方法执行的数据结构。是虚拟机运行时数据区中的虚拟机栈的栈元素

- 每一个方法从调用开始至执行完成的过程，对应一个帧栈在虚拟机栈里面从入栈到出栈的过程。

- 活动线程中，位于栈顶的栈帧才是有效的，成为 当前栈帧 Current Stack Frame，相关联的方法为当前方法。

  ![栈帧结构](https://i.loli.net/2019/03/07/5c8128d06d776.png)

- 局部变量表——存放方法参数和方法内部定义的局部变量。
  - 局部变量以变量槽 Slot 为最小单位。
  - 类变量即使不在初始化中赋初值，也有系统分配零值。但局部变量不可。
- 操作数栈 Operand Stack
  - 用来执行方法内的各种操作
  - 举例：加法指令 iadd 运行时操作数栈中最接近栈顶的两个元素出栈并相加
  - 虚拟机解释执行引擎称为“基于栈的执行引擎”，其中，栈即是操作数栈。

### 8.3 方法的调用

> Class 文件的编译过程不包括传统编译中的连接，一切方法调用在 Class 文件里面存储的都只是符号引用。

#### 解析 Resolution

- 类的加载阶段，有部分符号引用转化为直接引用
- 这类方法在程序运行前就是确定的调用版本。
- 静态方法、私有方法、实例构造器、父类方法 4 类，非虚方法。不会被重写。

#### 分派 Dispatch —— “多态”的实现，重载、重写原理。

> 重载 Overloading : 一个类中多态性的一种表现。 [Java](http://java.chinaitlab.com/)的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。
>
> 重写 Overriding：父类与子类之间的多态性，对父类的函数进行重新定义。

- 静态分派

> `Human man = new Man()`
>
> man 变量静态类型是 Human，实际类型是 Man
>
> 静态类型 Static Type: 又称为外观类型。
>
> 实际类型：Actual Type

​	依赖静态类型来定位方法执行版本的分派动作称为静态分派，发生在编译阶段。典型应用是重载。

```java
sr.sayHello(man);
// sayHello 方法会判断 man 为 Human 类型
```

​	区分 解析：不同层次的筛选、明确目标方法的过程。静态方法会在类加载时解析，但也可以拥有重载版本。

- 动态分派
  - 典型应用——重写
  - 在运行期间根据实际类型确定方法的执行版本的分派过程
- java 是静态多分派，动态单分派的语言

#### 解释执行引和编译执行

- 解释执行
  - 由解释器根据输入的数据当场执行而不生成任何目标程序。
  - Java 生成字节码文件 class，然后由解释器 JVM 执行，不生成目标程序。
- 编译执行
  - 生成二进制机器码程序

#### 基于栈的指令集和基于寄存器的指令集

- 基于栈的指令集结构 Instruction Set Architecture ISA：运算过程即是数据出栈入栈执行指令的过程。
  - 可移植、代码紧凑、实现简单
  - 速度慢，代码多（出栈入栈）
- 基于寄存器的指令集：PC机中直接支持的指令集结构—x86 二地址指令集。速度快